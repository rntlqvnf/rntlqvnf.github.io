---
title: "&#91;OS&#93; File System Implementation (2)"
layout: kb-post
categories:
  - Lecture Notes
tags:
  - OS
  - CSED312
toc: true
toc_sticky: true
type: profession
---

> 이 글은 포스텍 박찬익 교수님의 CSED312 운영체제 수업의 강의 내용과 자료를 기반으로 하고 있습니다.

지난 방학에 쓰겠다고 했었는데 멘탈 놓고 놀아버리는 바람에 늦어졌다.

솔직히 수업 내용이 좀 가물가물하긴 한데... 최대한 열심히 써봐야겠다.

# 1. Overview

이번 시간의 주제는 **reliability** 이다.

**Reliability**, 신뢰성이란 데이터가 올바르게 저장되어있는지 신뢰할 수 있는가? 에 관한 문제이다.

이 문제를 처음 접한다면 '아니 데이터가 그럼 똑바로 저장되어있지 이상하게 저장되어있기라도 한가?' 하고 의문을 가질 수 있다.

어째서 이 논의가 필요한지 알기 위해서는 **recovery**를 알아야 한다.

**Recovery**, 복구는 컴퓨터가 crash로부터 데이터를 복원하는 과정을 말한다.

이 문장에 함축되어 있는 의미를 찾을 수 있어야 한다. 

우리가 파일 시스템에 대한 논의를 시작하면서 이전까지는 고려하지 않았던 크래시라는 새로운 상황이 도입되었다. 왜 이걸 고려해야만 할까?

이를 알기 위해선 파일이 어떻게 저장되는지를 이해할 필요가 있다.

컴퓨터 데이터 저장소는 크게 RAM과 하드 디스크로 나뉜다. RAM은 전원 종료시 데이터가 소실되고, 하드 디스크는 남는다.

왜 전원 종료하면 데이터가 사라지는 불안정해보이는 RAM을 도입했을까? 

마프 시간 때 배웠겠지만, 디스크 접근은 정말 엄청나게 느리기 때문이다.

그래서 컴퓨터는 필요한 데이터를 디스크에서 꺼내와 RAM에서 작업을 처리한 다음 수정된 데이터를 다시 디스크에 저장하는 방식을 취하고 있다.

그런데 문제는 만약 크래시가 난다면 RAM에 들어있는 데이터가 전부 사라진다. 사용자 입장에서는 날벼락이다.

RAM이 없다고 해도 문제는 여전하다. 

파일 생성, 파일 이동 등의 파일 동작들은 일련의 디스크 접근이 필요하다. 만약 동작 도중에 크래시가 난다면 디스크에 잘못된 형태의 파일이 남아버린다.

예를 들어 파일 생성은 헤더와 데이터를 위한 공간을 만들고, 헤더를 쓰고, 디렉토리에 파일을 추가하는 과정을 거치는데 만약 헤더를 쓰는 도중 크래시가 난다면 파일은 있는데 어디에도 소속되지 못한 파일이 만들어져버린다.

정리하자면 크래시는 파일 시스템의 consistency를 망가뜨린다. 

기본적으로 언제든 크래시가 날 수 있음을 가정하고 recovery 시스템을 디자인해야 한다.

그런데 recovery가 정말로 크래시 이전의 파일을 복구해낸걸까? 바로 이게 reliability 문제이다.



[I_1]: /assets/lecture/os/impl/named.PNG